{"version":3,"sources":["../../src/plugins/breakpoint.js"],"names":["Breakpoint","sizes","resolveBoundaries","current","compute","callbacks","output","sorted","Object","keys","map","key","value","sort","a","b","i","length","nextValue","Infinity","min","max","window","addEventListener","onResize","listen","$emit","breakpoint","computed","name","callback","push","indexOf","splice","up","innerWidth","range","from","to","Plugin"],"mappings":"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","file":"breakpoint.js","sourcesContent":["import Plugin from '../plugin'\r\n\r\nexport default class Breakpoint extends Plugin {\r\n\r\n\r\n  /**\r\n   * New Breapoint plugin\r\n   * @param {Object} opts \r\n   * @param {Object} opts.sizes of breakpoint sizes\r\n   */\r\n  constructor({ sizes }) {\r\n    super() \r\n    this.sizes = this.resolveBoundaries(sizes)\r\n    this.current = this.compute()\r\n    this.callbacks = []\r\n  }\r\n\r\n\r\n  /**\r\n   * Compute breakpoints with boudaries\r\n   * @param {Object} sizes\r\n   * @return {Object}\r\n   */\r\n  resolveBoundaries(sizes) {\r\n    const output = {}\r\n    const sorted = Object.keys(sizes).map(key => ({ key, value: sizes[key] })).sort((a, b) => a[1] - b[1])\r\n    for(let i = 0; i < sorted.length; i++) {\r\n      const current = sorted[i]\r\n      const nextValue = sorted[i + 1] ? (sorted[i + 1].value - 1) : Infinity\r\n      output[current.key] = { min: current.value, max: nextValue }\r\n    }\r\n    return output\r\n  }\r\n\r\n\r\n  /**\r\n   * Build plugin necessities\r\n   */\r\n  onInit() {\r\n    window.addEventListener('resize', e => this.onResize())\r\n    this.listen(breakpoint => this.$emit('breakpoint', breakpoint))\r\n  }\r\n\r\n\r\n  /**\r\n   * Listen viewport resize and compute breakpoint\r\n   * @param {Function} callback \r\n   */\r\n  onResize() {\r\n    const computed = this.compute()\r\n    if(computed.name !== this.current.name) {\r\n      this.current = computed\r\n      for(let i = 0; i < this.callbacks.length; i++) {\r\n        this.callbacks[i](computed)\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Add listener on resize event\r\n   */\r\n  listen(callback) {\r\n    this.callbacks.push(callback)\r\n  }\r\n\r\n\r\n  /**\r\n   * Remove listener\r\n   * @param {Function} callback \r\n   */\r\n  clear(callback) {\r\n    const i = this.callbacks.indexOf(callback)\r\n    this.callbacks.splice(i, 1)\r\n  }\r\n\r\n\r\n  /**\r\n   * Compute breakpoint from window width\r\n   */\r\n  compute() {\r\n    let name = null\r\n    for(let key in this.sizes) {\r\n      if(this.up(key)) name = key\r\n    }\r\n    return { name, value: window.innerWidth }\r\n  }\r\n\r\n\r\n  /**\r\n   * Check if size is above specific breakpoint\r\n   * @param {String} name \r\n   * @return {Boolean}\r\n   */\r\n  up(name) {\r\n    return (window.innerWidth >= this.sizes[name].min)\r\n  }\r\n\r\n\r\n  /**\r\n   * Check if size is under specific breakpoint\r\n   * @param {String} name \r\n   * @return {Boolean}\r\n   */\r\n  down(name) {\r\n    return (window.innerWidth <= this.sizes[name].max)\r\n  }\r\n\r\n\r\n  /**\r\n   * Check if size is in a specific breakpoint\r\n   * @param {String} name \r\n   * @return {Boolean}\r\n   */\r\n  only(name) {\r\n    return this.range(name, name)\r\n  }\r\n\r\n\r\n  /**\r\n   * Check if size is between specific breakpoints\r\n   * @param {String} from \r\n   * @param {String} to \r\n   */\r\n  range(from, to) {\r\n    return (\r\n      window.innerWidth >= this.sizes[from].min &&\r\n      window.innerWidth <= this.sizes[to].max\r\n    )\r\n  }\r\n\r\n}"]}