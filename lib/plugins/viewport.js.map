{"version":3,"sources":["../../src/plugins/viewport.js"],"names":["Viewport","config","animations","observers","Object","assign","animOffset","attributes","attrAnim","attrLazy","$on","map","o","disconnect","scope","target","once","enter","leave","offset","callback","hasEntered","observer","IntersectionObserver","i","entries","length","isIntersecting","unobserve","root","rootMargin","els","NodeList","observe","push","Plugin"],"mappings":";;;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;;;;;;;IAEqBA,Q;;;AAEnB;;;;;;AAMA,0BAAoC;AAAA,QAAtBC,MAAsB,QAAtBA,MAAsB;AAAA,QAAdC,UAAc,QAAdA,UAAc;;AAAA;;AAAA;;AAGlC,UAAKC,SAAL,GAAiB,EAAjB;AACA,UAAKD,UAAL,GAAkBA,UAAlB;;AAEA,UAAKD,MAAL,GAAcG,OAAOC,MAAP,CAAc;AAC1BC,kBAAY;AADc,KAAd,EAEXL,MAFW,CAAd;;AAIA,UAAKM,UAAL,GAAkB;AAChB,mBAAaC,kBADG;AAEhB,kBAAYC;AAFI,KAAlB;AAVkC;AAcnC;;AAGD;;;;;;;6BAGS;AAAA;;AAEP;AACA,WAAKC,GAAL,CAAS,eAAT,EAA0B,gBAAQ;AAChC,eAAKP,SAAL,CAAeQ,GAAf,CAAmB;AAAA,iBAAKC,EAAEC,UAAF,EAAL;AAAA,SAAnB;AACA,eAAKV,SAAL,GAAiB,EAAjB;AACD,OAHD;AAID;;AAGD;;;;;;;;;;;;;;mCAWuF;AAAA,UAA7EW,KAA6E,SAA7EA,KAA6E;AAAA,UAAtEC,MAAsE,SAAtEA,MAAsE;AAAA,6BAA9DC,IAA8D;AAAA,UAA9DA,IAA8D,8BAAvD,IAAuD;AAAA,8BAAjDC,KAAiD;AAAA,UAAjDA,KAAiD,+BAAzC,IAAyC;AAAA,8BAAnCC,KAAmC;AAAA,UAAnCA,KAAmC,+BAA3B,KAA2B;AAAA,UAApBC,MAAoB,SAApBA,MAAoB;AAAA,UAAZC,QAAY,SAAZA,QAAY;;;AAErF;AACA,UAAIC,aAAa,KAAjB;;AAEA;AACA,UAAMC,WAAW,IAAIC,oBAAJ,CAAyB,mBAAW;;AAEnD;AACA,aAAI,IAAIC,IAAI,CAAZ,EAAeA,IAAIC,QAAQC,MAA3B,EAAmCF,GAAnC,EAAwC;;AAEtC;AACA;AACA;AACA,cAAIP,SAASQ,QAAQD,CAAR,EAAWG,cAArB,IAAyCN,cAAcH,KAAd,IAAuB,CAACO,QAAQD,CAAR,EAAWG,cAA/E,EAAgG;;AAE9F;AACA,gBAAGV,SAAS,CAACI,UAAb,EAAyBA,aAAa,IAAb;;AAEzB;AACAD,qBAASK,QAAQD,CAAR,EAAWT,MAApB,EAA4BU,QAAQD,CAAR,CAA5B;;AAEA;AACA,gBAAGR,IAAH,EAASM,SAASM,SAAT,CAAmBH,QAAQD,CAAR,EAAWT,MAA9B;AACV;AACF;AACF,OApBgB,EAoBd,EAAEc,MAAMf,KAAR,EAAegB,YAAYX,MAA3B,EApBc,CAAjB;;AAsBA;AACA,UAAMY,MAAOhB,kBAAkBiB,QAAnB,GAA+BjB,MAA/B,GAAwC,CAACA,MAAD,CAApD;AACA,WAAI,IAAIS,IAAI,CAAZ,EAAeA,IAAIO,IAAIL,MAAvB,EAA+BF,GAA/B;AAAoCF,iBAASW,OAAT,CAAiBF,IAAIP,CAAJ,CAAjB;AAApC,OA9BqF,CAgCrF;AACA,WAAKrB,SAAL,CAAe+B,IAAf,CAAoBZ,QAApB;AACA,aAAOA,QAAP;AACD;;;;EApFmCa,gB;;kBAAjBnC,Q","file":"viewport.js","sourcesContent":["import Plugin from '../plugin'\r\nimport attrAnim from './viewport/attr-anim'\r\nimport attrLazy from './viewport/attr-lazy'\r\n\r\nexport default class Viewport extends Plugin {\r\n\r\n  /**\r\n   * New viewport plugin\r\n   * @param {Object} opts\r\n   * @param {Object} opts.config\r\n   * @param {Object} opts.animations list of JS animations\r\n   */\r\n  constructor({ config, animations }) {\r\n    super()\r\n\r\n    this.observers = []\r\n    this.animations = animations\r\n\r\n    this.config = Object.assign({\r\n      animOffset: '-120px'\r\n    }, config)\r\n\r\n    this.attributes = {\r\n      'data-anim': attrAnim,\r\n      'data-src': attrLazy,\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Bind plugin necessities\r\n   */\r\n  onInit() {\r\n\r\n    // clear observers (@todo reduce scope to root param)\r\n    this.$on('dom.destroyed', root => {\r\n      this.observers.map(o => o.disconnect())\r\n      this.observers = []\r\n    })\r\n  }\r\n\r\n\r\n  /**\r\n   * Observe an element when it intersects in the viewport\r\n   * @param {Object}                opts\r\n   * @param {HTMLElement}           opts.scope      parent element to set the scope\r\n   * @param {HTMLElement|NodeList}  opts.target     element(s) to observe in the scope\r\n   * @param {Boolean}               opts.once       trigger only once and destroy the listener\r\n   * @param {Boolean}               opts.enter      trigger only when the element appears\r\n   * @param {Boolean}               opts.leave      trigger only when the element disappears\r\n   * @param {String}                opts.offset     margin around scope to defer trigger\r\n   * @param {Function}              opts.callback   action to call\r\n   */\r\n  observe({ scope, target, once = true, enter = true, leave = false, offset, callback }) {\r\n\r\n    // keep track of element entering at least once\r\n    let hasEntered = false\r\n\r\n    // create viewport observer\r\n    const observer = new IntersectionObserver(entries => {\r\n\r\n      // for all observed elements\r\n      for(let i = 0; i < entries.length; i++) {\r\n\r\n        // process if :\r\n        // - `enter` is specified and element is entering the viewport\r\n        // - `leave` is specified and element is leaving after entering at least once\r\n        if((enter && entries[i].isIntersecting) || (hasEntered && leave && !entries[i].isIntersecting)) {\r\n\r\n          // set element has entered once\r\n          if(enter && !hasEntered) hasEntered = true\r\n\r\n          // call the action, give the element as first param\r\n          callback(entries[i].target, entries[i])\r\n\r\n          // unobserve if the `once` is specifies\r\n          if(once) observer.unobserve(entries[i].target)\r\n        }\r\n      }\r\n    }, { root: scope, rootMargin: offset })\r\n\r\n    // start to observe element(s)\r\n    const els = (target instanceof NodeList) ? target : [target]\r\n    for(let i = 0; i < els.length; i++) observer.observe(els[i])\r\n\r\n    // register observer for futur destruction\r\n    this.observers.push(observer)\r\n    return observer\r\n  }\r\n\r\n}"]}